#!/usr/local/bin/perl

=head1 NAME

slaymake - Calls Slay::Makefile module as if a make program

=head1 DESCRIPTION

Calls Slay::Makefile module as if a make program.  If no targets are
specified, then the first constant set of targets in the Slay::Makefile
is built.

=head1 USAGE

  slaymake [options] [targets]

Options:

  -d               Supply the debug flag to Slay::Maker
  -f <filename>    Use <filename> as the name of the SlayMakefile 
                   (default SlayMakefile)
  -h               Print help
  -V               Print version information

=cut

=pod
=begin reST
=begin Id
Id: ${TOOL_ID}.
Copyright (c) 2007 Mark Nodine.
Distributed under terms of the Perl license, which is the disjunction of
the GNU General Public License (GPL) and the Artistic License.
=end Id

=cut

use FindBin;

use Slay::Makefile; our $VERSION = $Slay::Makefile::VERSION;

use strict;
use vars qw($TOOL_ID);

main();

sub main {
    use Getopt::Long;
    
    $TOOL_ID = "slaymake $VERSION";
    # Set default option values
    my %opt = (f=>'SlayMakefile');

    # Parse options
    Getopt::Long::config('no_ignore_case');
    Usage() unless GetOptions \%opt, qw(d f=s h V);
    # Give usage information
    Usage('DESCRIPTION') if $opt{h};
    Usage('Id') if $opt{V};

    my %options;
    $options{debug} = 1 if $opt{d};
    my $sm = Slay::Makefile->new(\%options);
    my $errs = $sm->parse($opt{f});
    if (@$errs) {
	print STDERR @$errs;
	print STDERR "Targets not built due to errors\n";
    }
    else {
	$sm->make(@ARGV);
	print $sm->maker->output;
    }
}

# Extracts and prints usage information
# Arguments: type of usage, end marker for usage (optional)
sub Usage {
    my ($what) = @_;
    $what = "USAGE" if ! $what;
    my $mark = $what eq 'DESCRIPTION' ? "($what|USAGE)" : $what;
    # Devel::Cover branch 0 1 Assert I can open myself
    if (open(ME,$0)) {
	while (<ME>) {
	    if ((/^=(begin|head1) $mark/ .. /^=(end $mark|cut)/) &&
		! /^=((begin|end) $mark|cut)/) {
		s/(\$\{[^\}]+\})/eval($1)/ge;
		s/=head1 //;
		print;
	    }
	}
	close(ME);
    }
    else {
	# Devel::Cover statement 0 0 guards internal error
	print STDERR "Usage not available.\n";
    }
    exit (1);
}
